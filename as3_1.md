# 전공조사

## 프론트엔드
**사용자가 상호작용 가능한 앱의 화면을 만드는 분야**

### ➤ 주요역할
- 웹사이트나 앱의 구조,디자인을 코드로 구현
- 다양한 화면크기(PC,모바일)에 대응하는 디자인

### ➤ 다른 역할
- API통신 : 서버와 연결해 실제 데이터 받기(백엔드랑 연결)
- 상태관리 : 사용자 인터랙션이나 데이터 변경에 따라 화면이 반응하도록 관리

### ➤ 사용하는 기술(언어)
- HTML : 웹의 뼈대
- CSS : 웹의 디자인 요소
- JavaScript : 웹의 동작
- React : facebook에서 만든 프론트엔드 라이브러리
- Vue : 진입이 가볍고 확장이 강한 프론트엔드 라이브러리
- Angular : TypeScript가 기반인 완전한 프레임워크

### ➤ 필수 개념
- DOM조작
- 상태관리

### ➤ 도구
- Figma랑 연동(디자이너가 Figma로 디자인 시안을 만들면,프론트 개발자는 그걸 보고 실제 화면을 구현
- Vite, Webpack

---

## 백엔드
**프론트가 준 요청을 받아 논리적으로 처리하고, 데이터를 저장/보내주는 역할**

### ➤ 주요역할
- 데이터베이스랑 연결
- 사용자 인증/보안
- 서버 로직 작성(서버가 대충 어떻게 돌아갈지 하는 코드 같은거)

### ➤ 사용하는 기술(언어)
- Python (Django, Flask) : 개발이 편해요(문법이 간단하고 직관적, 코드 양이 적고 빠르게 개발 가능)
- Java(Spring boot) : 대기업, 대형 시스템이 좋아함(높은 안정성,객체 지향 구조가 체계적이라 대규모 서비스에 최적임)
- Go : 속도가 빠르고 도시처리가 강함 / Ruby : 개발속도가 빠름(생산성에 초점) / PHP : 오래된 웹사이트나 CMS가 대부분 이거 기반

### ➤ 필수 개념(데이터 베이스)
- 관계형 : MySQL, PostgreSQL
- 비관계형 : MongoDB, Redis.

---

## 디자인
**프로그래밍보단 사용자의 시선에 취지를 둔 분야**

### ➤ UI
- 대충 여러 시각적 요소(색상,폰트,버튼,구성) 
- 앱/웹을 이쁘게 구성함

### ➤ UX
- 사용자 흐름을 설계(대충 몇번 클릭하면 원하는 기능에 도달하냐)
- 사용자가 헷갈리지 않게, 편리하게 설계

### ➤ 사용하는 도구
- Figma, Adobe XD, Sketch
- 프로토타입 제작, 와이어프레임 설계

### ➤ 개발자와의 협업
- 디자인 파일을 넘긴 후, 프론트개발자가 그것을 구현
- 디자인 시스템, 스타일 가이드를 공유

---

## 클라우드
**만든거(서비스) 웹에다가 배포, 자동화나 인프라 운영 담당분야**

### ➤ 주요역할
- 서버 세팅, 베포 자동화
- 트래픽에 따라 서버 자동확장
- 오류 모니터링, 백업, 보안 관리

### ➤ 사용하는 기술(with플랫폼)
- AWS / Azure / Google Cloud / Naver Cloud 등
- Docker / Kubernetes – 컨테이너 관리 (docker들어본듯함)

### ➤ 필수 개념
- 가상서버
- 스토리지
- 무중단 배포, 오토스케일링, 로깅/모니터링

---

## 협업흐름
디자이너가 화면 설계(프론트에게 figma 디자인 파일 전달) ->  
프론트가 HTML/CSS/JS구현(어떤 API로 받아올건지 백엔드와 논의 후 명세서 기반으로 연동) ->  
백이 데이터를 서버에서 처리하고 응답(만든 API 서버를 어디에 배포할지 공유)  ->  
클라우드가 프론트/백엔드가 만든 코드를 안정적으로 배포 (완 * 벽)

---

# HTTP

## 개념&역할
웹에서 클라이언트(대충 사용자?)와 서버가 데이터를 주고 받기 위한 통신 규칙,  
클라이언트가 요청(Request)를 보내면 서버가 응답(Response)를 보냄

---

## 특징

### ➤ Stateless(무상태성) 
- 요청끼린 따로 놀고(독립적), 이전 내용을 기억못함 (전에 했던거죠)
- 구조가 단순해서 처리가 빨라요, 확장성이 굿
- 보완기술 존재(쿠키, 세션 등)

### ➤ 클라이언트-서버 구조
- 클라이언트 (요청보내는 쪽 / 웹 브라우저,모바일 앱 같은거)
- 서버 (요청을 처리하고 응답함 / 웹 서버, API 서버)

### ➤ 무연결
- 요청 - 응답이 끝나면 연결 종료(정이 없어)

### ➤ 텍스트 기반 프로토콜
- 요 - 응이 텍스트로 이루어짐

### ➤ 확장성
- 새 기능추가가 쉬움

---

## 주요 메서드  
**멱등성** : 같은 요청을 여러 번 보내도, 서버상태는 한번 요청한 것과 동일해야한다는 성질

| 메서드 | 기능 | 특징 | 멱등성 |
|--------|------|------|--------|
| GET | 데이터 가져오기 | 서버에 리소스 열람을 요청<br>주소창(사용가능), 데이터 바꿈X, ?key=value을 URL뒤에 붙여 전송 | ✅ |
| POST | 데이터 생성하기 | 서버에 새로운 데이터를 전송해서 생성<br>보통 폼데이터, JSON 형식으로 전송, 서버에 변화O | ❌ |
| PUT | 데이터 전체 수정 | 기존 데이터 덮어쓰기<br>해당 리소스를 모두 교체하는 느낌, 자주는 아니나 API에 종종 사용 | ✅ |
| DELETE | 데이터 삭제 | 특정 리소스를 삭제 (이름 = 기능 의 표본인데)<br>요청만으로 데이터를 삭제하기에 사용에 주의가 필요함 | ✅ |
| PATCH | 소규모 PUT | 일부만 수정한다는 뜻 | ❌ (보통X) |
| HEAD | 얜 GET과 비슷하지만 본문이 읎어요 | - | ✅ |
| OPTIONS | 사용가능 메서드를 확인 | - | ✅ |

---

## 상태 코드

### ➤ 1XX : 처리중

### ➤ 2XX : 성공
- 200(OK) : 요청 처리 -완-  
- 201(Created) : 리소스 생성 -완-

### ➤ 3XX : 리다이렉션(다른곳으로 이동)

### ➤ 4XX : 클라이언트 오류
- 400(Bad Request) : 요청 형식에 오류  
- 401(Unauthorized) : 인증필요 or 토큰이 잘못됨  
- 403(Forbidden) : 권한이 없음  
- 404(Not Found) : 요청 페이지,리소스를 찾지 못함

### ➤ 5XX : 서버오류
- 500(Internal Server Error) : 서버 내부 오류 (만든놈 잘못)  
- 502(Bad Gateway) : 다른 서버에서 응답을 잘못 받음(프록시 잘못)  
- 503(Service Unavailable) : 서버를 일시적 사용 불가 (점검 잘못(?))

---

## 내부 동작 방식

1. HTTP 요청을 브라우저에서 작성  
2. 이 요청은 TCP를 통해 신뢰성 있게 열결됨  
3. 데이터는 IP로 나눠지고, 라우팅을 통해 전송  
4. 결국 데이터는 WiFifmf 통해 물리적으로 전송

### ➤ HTTP와 TCP
- HTTP는 TCP위에서 동작(HTTP가 메시지 제작, TCP가 안정적으로 전송)
- TCP가 3-way Handshake 방식으로 선 연결  
  그 연결이 안정적이여야 요청/응답 정상작동

### ➤ HTTP와 IP
- IP가 주소전담
- IP주소가 패킷이 어디로 가야 하는지 알려줌

### ➤ HTTP와 DNS
- DNS가 도메인 이름을 IP주소로 변환

---

## 요청-응답 구조

### ➤ 구성
- Start Line(시작줄) : 어떤 메서드인지, 경로는 어딘지, 어떤 버전인지  
- Header(헤더) : 요청 정보, 인증, 형식 등  
- Body : 실제 전송 데이터

### ➤ 요청 : 클라이언트 -> 서버
- Start Line(시작줄) : 메서드, 경로, 버전  
- Header(헤더) : 요청 정보  
- Body : 전송 데이터

### ➤ 응답 : 서버 -> 클라이언트
- Start Line(시작줄) : 버전, 상태코드 메시지  
- Header(헤더) : 응답 정보  
- Body : 반환 데이터

---

## 버전별 차이점

### ➤ 1.0
- 특징 : 요청마다 연결을 새로 열고 닫음(비효율적), 캐시기능이 있지만 단순  
- 단점 : 많은 요청을 하면 연겨을 수시로 맺어야 하기에 느림, 동시요청X

### ➤ 1.1
- 특징 : Persistent Connection 지원 (연결 유지) 연결하나로 여러 요청 가능,  
          파이브라이닝 기능 도입 (요청을 여러개 가능)
- 단점 : 여전히 요청이 순차적으로 처리, 요청이 많으면 성능저하

### ➤ 2
- 특징 : 하나의 연결에서 여러 요청/응답 동시 처리 가능, 헤더압축(중복제거)으로 부담 감소
- 단점 : 여전히 TCP 기반이라 패킷 손실 시 전체 지연 발생

### ➤ 3
- 특징 : TCP가 QUIC으로 교체(지연시간 감소), 헤더 압축, 멀피플렉싱 유지
- 단점 : 완전한 표준화 진행중, 구형 브라우저는 호환 어려움

---

## HTTPS

### ➤ 정의
HTTP 프로토콜 위에 SSL/TLS 암호화 계층을 추가해 보안을 강화한 버전

### ➤ 동작 과정
클라이언트가 서버한테 접속 요청 및 SSL인증서 요청 ->  
서버가 클라이언트에게 SSL인증서 전달 ->  
클라이언트가 공개키로 암호화한 세션키를 서버에 보냄 ->  
서버는 개인키로 복호화한 후 양쪽 모두 암호화된 통신 시작

### ➤ 보안 요소
- 암호화 : 중간에 누가 가로채더라도 내용 열람 불가  
- 무결성 : 데이터가 도중에 변조되지 않았는지 확인  
- 인증 : SSL 인증서를 통해 이 서버가 진짜 그 사이트가 맞는지 검증
